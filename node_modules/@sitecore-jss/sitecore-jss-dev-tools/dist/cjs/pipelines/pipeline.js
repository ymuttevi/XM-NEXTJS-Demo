"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.runWithCompilers = exports.run = exports.runProcessors = void 0;
const utils_1 = require("./utils");
const enhanceProcessors = (processors) => processors.map((processor) => {
    if (processor.modulePath) {
        const importArgs = {
            fileGlobs: [processor.modulePath],
        };
        if (processor.modulePath.workingDirectory && processor.modulePath.filePath) {
            importArgs.fileGlobs = [processor.modulePath.filePath];
            importArgs.workingDirectory = processor.modulePath.workingDirectory;
        }
        return Object.assign(Object.assign({}, processor), { moduleWrapper: utils_1.importModules(importArgs)[0] });
    }
    return processor;
});
const runProcessor = ({ processor, args }) => __awaiter(void 0, void 0, void 0, function* () {
    if (args && args.debug) {
        console.log(`executing processor ${processor.name}`);
    }
    const { args: processorArgs } = processor, otherProcessorInfo = __rest(processor, ["args"]);
    const mergedArgs = Object.assign(Object.assign(Object.assign({}, args), processorArgs), { processor: Object.assign({}, otherProcessorInfo) });
    // processors can be a function defined via processor.process
    // or they can be modules that need to be imported
    if (typeof processor.process === 'function') {
        const result = yield processor.process(mergedArgs);
        return result;
    }
    else if (processor.moduleWrapper) {
        const module = yield processor.moduleWrapper.import();
        if (module.default) {
            const resultArgs = module.default(mergedArgs);
            // resultArgs can be a promise or object, so this abort check won't work if resultArgs is a promise
            if (resultArgs.abort) {
                throw new Error('abort');
            }
            return resultArgs;
        }
        return args;
    }
    throw new Error(`Pipeline processor '${processor.name}' does not specify 'modulePath' or 'process'`);
});
/**
 * @param {Object} args
 * @param {Processor[]} args.processors the processors to run (optional but must be specified if pipeline is not specified)
 * @param {any} args.pipelineArgs arguments to pass to the pipeline processors
 */
const runProcessors = ({ processors, pipelineArgs = {}, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (!processors || processors.length === 0) {
        throw new Error('no processors specified to run');
    }
    const finalProcessors = enhanceProcessors(processors);
    let pipelineResult = pipelineArgs;
    // eslint-disable-next-line no-restricted-syntax
    for (const processor of finalProcessors) {
        // eslint-disable-next-line no-await-in-loop
        pipelineResult = yield runProcessor({ processor, args: pipelineResult });
    }
    return pipelineResult;
});
exports.runProcessors = runProcessors;
/**
 * @param {ExecutablePipeline} pipeline the pipeline to run (optional but must be specified if processors is not specified)
 */
const run = (pipeline) => __awaiter(void 0, void 0, void 0, function* () {
    if (!pipeline || !pipeline.processors() || pipeline.processors().length === 0) {
        throw new Error('no pipeline processors have been defined');
    }
    const pipelineName = pipeline ? `"${pipeline.name}" ` : '';
    if (pipeline.args.debug) {
        console.log(`\npipeline ${pipelineName}started`);
    }
    const pipelineResult = yield exports.runProcessors({
        processors: pipeline.processors(),
        pipelineArgs: pipeline.args,
    });
    if (pipeline.args.debug) {
        console.log(`pipeline ${pipelineName}complete`);
    }
    return pipelineResult;
});
exports.run = run;
/**
 * Run a pipeline, loading specified compilers first
 * @param {any} compilers
 * @returns {any} pipeline result
 */
const runWithCompilers = (compilers) => (pipeline) => __awaiter(void 0, void 0, void 0, function* () {
    yield utils_1.initCompilers(compilers);
    return exports.run(pipeline);
});
exports.runWithCompilers = runWithCompilers;
