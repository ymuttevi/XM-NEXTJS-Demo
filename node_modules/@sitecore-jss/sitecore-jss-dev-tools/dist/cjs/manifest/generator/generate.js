"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateToFile = exports.generateToVariable = void 0;
const pipelines_1 = require("../../pipelines");
const chalk_1 = __importDefault(require("chalk"));
const fs = __importStar(require("fs-extra"));
const path = __importStar(require("path"));
const utils_1 = require("../utils");
const manifest_1 = require("./manifest");
const processSpecFile = (moduleWrapper, manifest) => __awaiter(void 0, void 0, void 0, function* () {
    const module = yield moduleWrapper();
    if (!module.default || typeof module.default !== 'function') {
        console.warn('no valid default export defined on module', module);
        return manifest;
    }
    const moduleResult = module.default(manifest);
    // spec files should only return undefined or a promise, we only care about the promise
    if (moduleResult && moduleResult.then) {
        // result is a promise
        // resolve the promise and return the manifest instance so that any non-async spec files
        // after the current file will receive the manifest instance as an argument
        return moduleResult.then(() => manifest);
    }
    return manifest;
});
const processSpecFiles = ({ fileGlobs, manifestInstance, }) => __awaiter(void 0, void 0, void 0, function* () {
    const moduleWrappers = utils_1.importModules({ fileGlobs });
    let manifest = manifestInstance;
    for (const moduleWrapper of moduleWrappers) {
        // eslint-disable-next-line no-await-in-loop
        manifest = yield processSpecFile(moduleWrapper, manifest);
    }
    return manifest;
});
const initRequire = (requireArg) => {
    if (!requireArg) {
        return;
    }
    try {
        if (requireArg.startsWith('.')) {
            requireArg = path.join(process.cwd(), requireArg);
        }
        require(requireArg);
    }
    catch (e) {
        throw new Error(`Unable to load manifest require ${requireArg}: ${e}`);
    }
};
const copyMedia = (mediaPaths, outputPath) => {
    const seen = new Set();
    return mediaPaths
        .filter((item) => (seen.has(item.src) ? false : seen.add(item.src)))
        .map((mediaPath) => {
        if (!mediaPath.src) {
            console.warn(`Media field value ${JSON.stringify(mediaPath)} did not have an expected 'src' property. Its media item will not be deployed.`);
            return { success: false };
        }
        const mediaSourcePath = path.isAbsolute(mediaPath.src) ? `.${mediaPath.src}` : mediaPath.src;
        if (fs.existsSync(mediaSourcePath)) {
            if (!fs.statSync(mediaSourcePath).isFile()) {
                console.warn(`Source media path referred to in manifest data is not a file: ${mediaSourcePath}`);
                return { success: false };
            }
            const mediaDestinationPath = path.join(path.dirname(outputPath), mediaPath.src);
            const mediaDestinationFolder = path.dirname(mediaDestinationPath);
            fs.ensureDirSync(mediaDestinationFolder);
            fs.copySync(mediaSourcePath, mediaDestinationPath);
            console.log(`copied media from: ${mediaSourcePath} to: ${mediaDestinationPath}`);
            return { source: mediaSourcePath, destination: mediaDestinationPath, success: true };
        }
        throw `Source media file referred to in manifest data doesn't exist: ${mediaSourcePath}`;
    });
};
const writeOutput = ({ outputPath, manifest, excludeMedia, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (outputPath !== 'console') {
        yield fs.ensureFile(outputPath);
        // we copy the media first, because we no longer need the media prop after that
        if (!excludeMedia && manifest.media) {
            copyMedia(manifest.media, outputPath);
        }
        // we remove the media prop as it's unused by the manifest after copying media
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { media } = manifest, finalManifest = __rest(manifest, ["media"]);
        yield fs.writeJson(outputPath, finalManifest, { spaces: 2 });
        console.log(chalk_1.default.green(`Manifest has been generated and written to ${outputPath}`));
        return finalManifest;
    }
    console.log('manifest', JSON.stringify(manifest, null, 2));
    return manifest;
});
const getPipelineConfig = ({ patchGlobs }) => __awaiter(void 0, void 0, void 0, function* () {
    const manifestConfig = yield pipelines_1.configLoader({
        fileGlobs: ['./pipelines/**/pipeline.config.js'],
        workingDirectory: __dirname,
    });
    const patchedConfig = patchGlobs
        ? yield pipelines_1.configLoader({
            fileGlobs: patchGlobs,
            existingConfig: manifestConfig,
            allowEmptyGlobs: true,
        })
        : manifestConfig;
    return patchedConfig;
});
/**
 * generates the JSON manifest and returns it as a variable
 * NOTE: media is not copied into the manifest when using this method,
 * and no files are written to disk. Use generateToFile() to make a manifest
 * that is designed to get packaged/imported.
 *
 * @param {GenerateOptions} config
 */
function generateToVariable({ requireArg, fileGlobs, pipelines, appName, excludeItems = false, excludeDictionary = false, language, pipelinePatchFileGlobs, debug, wipe, rootPlaceholders, skipPlaceholderBlacklist, }) {
    return __awaiter(this, void 0, void 0, function* () {
        initRequire(requireArg);
        const finalPipelines = pipelines || (yield getPipelineConfig({ patchGlobs: pipelinePatchFileGlobs }));
        let manifestInstance = manifest_1.createManifestInstance({
            pipelines: finalPipelines,
            appName,
            excludeItems,
            excludeDictionary,
            language,
            debug,
            wipe,
            rootPlaceholders,
            skipPlaceholderBlacklist,
        });
        manifestInstance = yield processSpecFiles({ fileGlobs, manifestInstance });
        const manifestOutput = yield manifestInstance.getManifest();
        return manifestOutput;
    });
}
exports.generateToVariable = generateToVariable;
/**
 * generates a JSON manifest and writes its contents to a directory. Media referenced in the manifest
 * is also copied to the directory.
 *
 * @param {GenerateToFileOptions} config
 */
function generateToFile(_a) {
    var { outputPath = 'console', excludeMedia = false } = _a, generateToVariableOptions = __rest(_a, ["outputPath", "excludeMedia"]);
    return __awaiter(this, void 0, void 0, function* () {
        const manifestOutput = yield generateToVariable(generateToVariableOptions);
        return writeOutput({ outputPath, manifest: manifestOutput, excludeMedia });
    });
}
exports.generateToFile = generateToFile;
