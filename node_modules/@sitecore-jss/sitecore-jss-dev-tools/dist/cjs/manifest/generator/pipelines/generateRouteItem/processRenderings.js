"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const uuid_1 = require("uuid");
const manifest_types_1 = require("../../manifest.types");
const utils_1 = require("../../utils");
const JSS_UUID_NAMESPACE = '0e52892a-f862-4d08-9487-987617b637cd';
const generateRenderingParams = (component, rendering) => {
    if (!rendering.params) {
        return [];
    }
    const reducedParams = Object.keys(rendering.params).reduce((result, paramName) => {
        return [
            ...result,
            {
                name: paramName,
                value: rendering.params[paramName],
            },
        ];
    }, []);
    if (!Array.isArray(component.params)) {
        throw chalk_1.default.red(`An instance of ${component.name} defined param(s) '${reducedParams
            .map((rp) => rp.name)
            .join(', ')}', but the component definition did not define any params. Define them on the manifest component definition to use them. Instance definition: ${JSON.stringify(rendering, null, 2)}`);
    }
    // find params that are not defined in manifest
    const invalidParams = reducedParams.filter((param) => !component.params.some((componentParam) => (componentParam.name ? componentParam.name : componentParam) === param.name));
    if (invalidParams.length > 0) {
        const validParams = component.params.map((cp) => (cp.name ? cp.name : cp)).join(',');
        const invalidParamsString = invalidParams.map((ip) => ip.name).join(', ');
        throw chalk_1.default.red(`Param(s) ${invalidParamsString} defined on an instance of component ${component.name} was not defined on the component definition. Add it to the manifest component definition to use it. Valid params: ${validParams}. Instance definition: ${JSON.stringify(rendering, null, 2)}`);
    }
    return reducedParams;
};
const generateFields = (component, rendering, dataSourceItem, allComponents) => {
    if (!rendering.fields) {
        return [];
    }
    let renderingFields = rendering.fields;
    if (component) {
        const handleError = (fieldName) => {
            throw chalk_1.default.red(`${dataSourceItem.name} route datasource defined data for '${fieldName}' on component ${component.name}. This field is not defined on this component. It may be a typo, or the field may need to be added to the component definition.`);
        };
        renderingFields = utils_1.validateFieldDefinitions(rendering.fields, component, handleError, allComponents);
    }
    return utils_1.convertComponentDataToFields({ data: renderingFields, context: { item: dataSourceItem } });
};
const generateChildrenFields = (children) => {
    const [...result] = children;
    result.forEach((child) => {
        if (!manifest_types_1.isItemDefinition(child)) {
            return;
        }
        if (child.fields) {
            child.fields = utils_1.convertComponentDataToFields({
                data: child.fields,
                context: { item: child },
            });
        }
        if (child.children) {
            child.children = generateChildrenFields(child.children);
        }
    });
    return result;
};
const createDataSourceItem = (_a, component) => {
    var { rendering, datasourceNamer, datasourceDisplayNamer } = _a, context = __rest(_a, ["rendering", "datasourceNamer", "datasourceDisplayNamer"]);
    // rendering is an ID reference, not a whole rendering, so this will come from elsewhere
    // UNLESS it's a copy - in which case we still want it to get named as a local DS item
    if (!rendering.componentName && rendering.id && !rendering.copy) {
        return {};
    }
    const namerContext = Object.assign({ rendering }, context);
    const name = rendering.name ? rendering.name : datasourceNamer(namerContext);
    let displayName = rendering.displayName;
    if (!displayName) {
        displayName = rendering.name ? null : datasourceDisplayNamer(namerContext); // don't set anything if name provided w/ out displayName
    }
    const result = Object.assign({ name,
        displayName, template: (component === null || component === void 0 ? void 0 : component.templateName) || (component === null || component === void 0 ? void 0 : component.name) || rendering.componentName }, rendering);
    if (result.children) {
        result.children = generateChildrenFields(result.children);
    }
    delete result.fields;
    delete result.id;
    delete result.placeholders;
    delete result.uid;
    delete result.componentName;
    delete result.params;
    return result;
};
const generatePlaceholderKey = (dynamicPlaceholderKeyGenerator, placeholder, rendering) => {
    const phKey = dynamicPlaceholderKeyGenerator(placeholder.phKey, rendering, placeholder.phName);
    return phKey;
};
const generateRenderingUid = (renderingName, renderingIndex, parentPlaceholderKey) => {
    // 1. We calculate the deterministic namespace UUID for the parent placeholder
    const parentNamespace = uuid_1.v5(renderingName + parentPlaceholderKey, JSS_UUID_NAMESPACE);
    // 2. Using the parent UUID, we create a deterministic UUID for the rendering using its index in the placeholder
    const renderingUid = uuid_1.v5(renderingIndex.toString(), parentNamespace);
    // make the UID look Sitecore-ish
    return `{${renderingUid.toUpperCase()}}`;
};
const processRendering = (rendering, index, context) => {
    const newContext = Object.assign(Object.assign({}, context), { rendering, index });
    const component = utils_1.findComponent(rendering.componentName, context.components);
    // check for component def, as long as the component isn't an id-only ref
    // (defines id but not name)
    if (!component && rendering.componentName) {
        throw chalk_1.default.red(`The component '${rendering.componentName}' used on route '${context.route.name}' was not defined in the manifest. Please define this component with 'manifest.addComponent()', or change the name to an existing component name.`);
    }
    const dsItem = createDataSourceItem(newContext, component);
    const renderingParams = generateRenderingParams(component, rendering);
    const fields = generateFields(component, rendering, dsItem, context.components);
    dsItem.fields = fields;
    const layoutRendering = {
        renderingName: rendering.componentName,
        placeholderKey: context.placeholder.phKey,
        placeholderName: context.placeholder.phName,
        dataSource: dsItem,
        renderingParams,
    };
    if (rendering.id) {
        layoutRendering.id = rendering.id;
    }
    if (rendering.copy) {
        layoutRendering.copy = rendering.copy;
    }
    if (rendering.uid) {
        layoutRendering.uid = rendering.uid;
    }
    else {
        // assign a rendering instance uid for placeholder keys further down the tree
        layoutRendering.uid = generateRenderingUid(dsItem.name ? dsItem.name : layoutRendering.renderingName, index, context.placeholder.phKey);
        newContext.rendering.uid = layoutRendering.uid;
    }
    if (context.onRenderingProcessed) {
        context.onRenderingProcessed(layoutRendering);
    }
    if (rendering.placeholders) {
        processPlaceholders(newContext, rendering.placeholders);
    }
};
const processPlaceholders = (context, placeholders) => {
    if (!placeholders) {
        return;
    }
    Object.keys(placeholders).forEach((phName) => {
        const phKey = generatePlaceholderKey(context.dynamicPlaceholderKeyGenerator, Object.assign(Object.assign({}, context.placeholder), { phName }), context.rendering);
        const placeholder = {
            renderings: placeholders[phName],
            phName,
            phKey,
        };
        placeholder.renderings.forEach((rendering, index) => {
            processRendering(rendering, index, Object.assign(Object.assign({}, context), { placeholder }));
        });
    });
};
exports.default = (args) => {
    if (!args.route) {
        return args;
    }
    const { placeholders } = args.route;
    const renderings = [];
    const onRenderingProcessed = (rendering) => {
        renderings.push(rendering);
    };
    const context = Object.assign(Object.assign({}, args), { onRenderingProcessed });
    processPlaceholders(context, placeholders);
    // error if renderings don't have unique names
    const datasourceNames = renderings
        .map((rendering) => rendering.dataSource && rendering.dataSource.name)
        .filter((x) => x);
    const duplicateDatasourceNames = new Set(datasourceNames.filter((v, i) => datasourceNames.indexOf(v) !== i)); // https://stackoverflow.com/a/47298567/201808
    if (duplicateDatasourceNames.size > 0) {
        const dupes = JSON.stringify(Array.from(duplicateDatasourceNames));
        throw chalk_1.default.red(`Route "${args.item.name}" has rendering(s) with identical names: ${dupes}. Please assign unique rendering names using the 'name' property.`);
    }
    return Object.assign(Object.assign({}, args), { item: Object.assign(Object.assign({}, args.item), { layout: Object.assign(Object.assign({}, args.item.layout), { renderings }) }) });
};
