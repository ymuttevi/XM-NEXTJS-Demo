"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../../utils");
const validators_1 = require("../../validators");
exports.default = (args) => {
    const { components } = args;
    const templates = components.reduce((result, component) => {
        // throw if you defined a single ID for a component (which since it splits into a template + rendering, needs two explicit IDs set)
        if (component.id) {
            throw `The component ${component.name} defined an 'id'. Because a component becomes two separate items in Sitecore, it must have two separate IDs. Please specify unique 'templateId' and 'renderingId' properties instead.`;
        }
        // don't generate template for component without fields that inherits nothing
        if (!component.fields && !component.inherits) {
            return result;
        }
        const { templateId, templateName } = component, template = __rest(component, ["templateId", "templateName"]);
        if (templateId) {
            template.id = templateId;
        }
        if (templateName) {
            template.name = templateName;
        }
        delete template.renderingId;
        delete template.params;
        delete template.fieldEditorFields;
        delete template.displayFieldEditorButton;
        delete template.placeholders;
        delete template.allowedPlaceholders;
        delete template.graphQLQuery;
        delete template.customExperienceButtons;
        const validationResult = validators_1.validateTemplate(template);
        if (validationResult.valid) {
            return [...result, template];
        }
        throw validationResult.error;
    }, []);
    const finalTemplates = [...args.templates, ...templates];
    const duplicateIds = utils_1.checkUnique(finalTemplates, (template) => template.id);
    if (duplicateIds.length > 0) {
        throw `The manifest defined duplicate template IDs: ${duplicateIds.join(',')}. This is not allowed.`;
    }
    const duplicateNames = utils_1.checkUnique(finalTemplates, (template) => template.name);
    if (duplicateNames.length > 0) {
        throw `The manifest defined duplicate template names: ${duplicateNames.join(',')}. This is not allowed.`;
    }
    return Object.assign(Object.assign({}, args), { pipelineResult: Object.assign(Object.assign({}, args.pipelineResult), { templates: finalTemplates }) });
};
