"use strict";
/* eslint-disable */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDisconnectedDictionaryService = void 0;
function defaultCustomizeDictionary(dictionary, language, appName) {
    // turn dictionary from { key: foo, value: bar } into { foo: bar }
    const finalDictionary = dictionary.reduce((result, current) => {
        // eslint-disable-next-line no-param-reassign
        result[current.key] = current.value;
        return result;
    }, {});
    // restructure to look like dictionary service output
    return {
        lang: language,
        app: appName,
        phrases: finalDictionary,
    };
}
function createDisconnectedDictionaryService({ manifest, customizeDictionary, manifestLanguageChangeCallback, }) {
    let currentManifest = manifest;
    const service = {
        middleware: function disconnectedLayoutServiceMiddleware(request, response) {
            return __awaiter(this, void 0, void 0, function* () {
                const language = request.params.language ? request.params.language : 'en';
                const appName = request.params.appName ? request.params.appname : 'JssDisconnectedDictionary';
                // check to see if the language is different than what we have loaded, and if so change it
                // using the callback function if it is provided
                if (currentManifest.language.toUpperCase() !== language.toUpperCase()) {
                    if (manifestLanguageChangeCallback &&
                        typeof manifestLanguageChangeCallback === 'function') {
                        try {
                            currentManifest = yield manifestLanguageChangeCallback(language);
                        }
                        catch (e) {
                            console.error(`> [LAYOUT] Error getting manifest in language '${language}'`, e);
                            response.sendStatus(500);
                            return;
                        }
                    }
                    else {
                        console.error(`> [DICTIONARY] ERROR: Received request for dictionary in ${language} but the manifest data was in ${currentManifest.language}. To enable switching languages at runtime, please pass 'manifestLanguageChangeCallback: function(newLanguage) { return manifestInNewLanguage; }' in the service creation options.`);
                        response.sendStatus(404);
                        return;
                    }
                }
                if (!currentManifest.dictionary) {
                    console.log('Dictionary service: no dictionary in current manifest. An empty dictionary will be returned.');
                    response.sendStatus(404);
                }
                let finalDictionary = currentManifest.dictionary;
                finalDictionary = defaultCustomizeDictionary(finalDictionary, language, appName);
                if (customizeDictionary && typeof customizeDictionary === 'function') {
                    finalDictionary = customizeDictionary(finalDictionary, currentManifest.dictionary, request, response);
                }
                console.log(`> [DICTIONARY] served in ${language}`);
                response.json(finalDictionary);
            });
        },
        updateManifest(newManifest) {
            currentManifest = newManifest;
        },
    };
    service.updateManifest(manifest);
    return service;
}
exports.createDisconnectedDictionaryService = createDisconnectedDictionaryService;
