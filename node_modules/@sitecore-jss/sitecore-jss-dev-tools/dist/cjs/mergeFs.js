"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeFs = void 0;
const fs_1 = __importDefault(require("fs"));
const js_yaml_1 = __importDefault(require("js-yaml"));
const path_1 = __importDefault(require("path"));
const IS_HIDDEN_FILE = (file) => path_1.default.basename(file).startsWith('.');
const tryParseJsonOrYaml = (jsonString) => {
    try {
        const json = js_yaml_1.default.safeLoad(jsonString);
        // handle non-exception-throwing cases
        if (json && typeof json === 'object' && json !== null) {
            return json;
        }
    }
    catch (e) {
        console.error(e);
    }
    return false;
};
const processFileSync = (filePath, parseFileContents) => {
    // if no encoding is specified, readFileSync returns a buffer instead of a string
    const contents = fs_1.default.readFileSync(filePath, 'utf8');
    if (contents) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let contentObject;
        if (parseFileContents) {
            contentObject = parseFileContents(filePath, contents);
        }
        if (!contentObject) {
            contentObject = tryParseJsonOrYaml(contents);
        }
        if (contentObject) {
            return {
                filename: path_1.default.basename(filePath),
                path: path_1.default.resolve(filePath),
                contents: contentObject,
            };
        }
    }
    return null;
};
const readDirSync = (dir) => {
    const result = {
        filesList: [],
        dirList: [],
    };
    if (IS_HIDDEN_FILE(dir)) {
        return result;
    }
    const list = fs_1.default.readdirSync(dir);
    if (!list) {
        return result;
    }
    list.forEach((file) => {
        const filePath = path_1.default.join(dir, file);
        if (IS_HIDDEN_FILE(file)) {
            return;
        }
        const stats = fs_1.default.statSync(filePath);
        if (stats && stats.isDirectory()) {
            result.dirList.push(filePath);
        }
        else {
            result.filesList.push(filePath);
        }
    });
    return result;
};
const walkSync = (dir, parseFileContents, depth = 0) => {
    const results = {
        path: path_1.default.resolve(dir),
        name: path_1.default.basename(dir),
        files: [],
        folders: [],
    };
    const { filesList, dirList } = readDirSync(dir);
    results.files = filesList
        .map((file) => processFileSync(file, parseFileContents))
        .filter((file) => file)
        .map((file) => file);
    results.folders = dirList.map((dirPath) => walkSync(dirPath, parseFileContents, depth + 1));
    return results;
};
const mergeFs = (rootPath, parseFileContents) => new Promise((resolve, reject) => {
    if (!rootPath) {
        reject(new Error('rootPath is not defined'));
    }
    const result = walkSync(rootPath, parseFileContents);
    if (result) {
        resolve(result);
    }
    else {
        reject(new Error('no result generated'));
    }
});
exports.mergeFs = mergeFs;
