"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getHttpsTransport = exports.extractProxy = exports.packageDeploy = exports.logJobStatus = exports.finishWatchJobStatusTask = exports.doFingerprintsMatch = exports.normalizeFingerprint = exports.applyCertPinning = void 0;
const chalk_1 = __importDefault(require("chalk"));
const fs_1 = __importDefault(require("fs"));
const https_1 = __importStar(require("https"));
const path_1 = __importDefault(require("path"));
const form_data_1 = __importDefault(require("form-data"));
const axios_1 = __importDefault(require("axios"));
const digest_1 = require("./digest");
// Node does not use system level trusted CAs. This causes issues because SIF likes to install
// using a Windows trusted CA - so SSL connections to Sitecore will fail from Node.
// If the options.acceptCertificate is passed, we disable normal SSL validation and use this function
// to whitelist only a cert with the specific thumbprint - essentially certificate pinning.
/**
 * @param {ClientRequest} req
 * @param {PackageDeployOptions} options
 */
function applyCertPinning(req, options) {
    req.on('socket', (socket) => {
        socket.on('secureConnect', () => {
            const fingerprint = socket.getPeerCertificate().fingerprint;
            // Match the fingerprint with our saved fingerprint
            if (options.acceptCertificate &&
                !doFingerprintsMatch(options.acceptCertificate, fingerprint)) {
                // Abort request, optionally emit an error event
                req.emit('error', new Error(`Expected server SSL certificate to have thumbprint ${options.acceptCertificate} from acceptCertificate, but got ${fingerprint} from server. This may mean the certificate has changed, or that a malicious certificate is present.`));
                return req.abort();
            }
        });
    });
}
exports.applyCertPinning = applyCertPinning;
/**
 * @param {string} fp
 */
function normalizeFingerprint(fp) {
    //
    // The fingerprint for a certificate is a 20-byte value.
    // Such values are typically expressed as strings, but
    // there are many different formats that may be used.
    //
    // For example, the following values all represent
    // the same fingerprint:
    //  * 5E:D1:5E:D4:D4:42:71:CC:30:A5:B6:A2:DA:A4:79:06:67:CB:F6:36
    //  * 5ED15ED4D44271CC30A5B6A2DAA4790667CBF636
    //  * 5e:d1:5e:d4:d4:42:71:cc:30:a5:b6:a2:da:a4:79:06:67:cb:f6:36
    //  * 5ed15ed4d44271cc30a5b6a2daa4790667cbf636
    //
    // Before two fingerprints can be properly compared,
    // they must be converted into the same format. This
    // function implements the logic for that conversion.
    return fp.toLowerCase().replace(new RegExp(':', 'g'), '');
}
exports.normalizeFingerprint = normalizeFingerprint;
/**
 * @param {string} fp1
 * @param {string} fp2
 */
function doFingerprintsMatch(fp1, fp2) {
    return normalizeFingerprint(fp1) === normalizeFingerprint(fp2);
}
exports.doFingerprintsMatch = doFingerprintsMatch;
/**
 * @param {Object} params
 * @param {string[]} params.warnings
 * @param {string[]} params.errors
 * @param {Function} params.resolve
 * @param {Function} params.reject
 */
function finishWatchJobStatusTask({ warnings, errors, resolve, reject, }) {
    console.log();
    console.log('Import is complete.');
    if (warnings.length) {
        console.log();
        console.warn(chalk_1.default.yellow('IMPORT WARNING(S) OCCURRED!'));
        warnings.forEach((w) => console.error(chalk_1.default.yellow(w)));
    }
    if (errors.length) {
        console.log();
        console.error(chalk_1.default.red('IMPORT ERROR(S) OCCURRED!'));
        errors.forEach((e) => console.error(chalk_1.default.red(e)));
        reject();
    }
    else {
        resolve();
    }
}
exports.finishWatchJobStatusTask = finishWatchJobStatusTask;
/**
 * @param {Object} params
 * @param {string} params.message
 * @param {string} params.entryLevel
 * @param {string[]} params.warnings
 * @param {string[]} params.errors
 */
function logJobStatus({ message, entryLevel, warnings, errors, }) {
    switch (entryLevel) {
        case 'WARN':
            console.warn(chalk_1.default.yellow(message));
            warnings.push(message);
            break;
        case 'ERROR':
            console.error(chalk_1.default.red(message));
            errors.push(message);
            break;
        case 'DEBUG':
            console.log(chalk_1.default.white(message));
            break;
        default:
            console.log(chalk_1.default.green(message));
            break;
    }
}
exports.logJobStatus = logJobStatus;
/**
 * @param {PackageDeployOptions} options
 * @param {string} taskName
 */
function watchJobStatus(options, taskName) {
    return __awaiter(this, void 0, void 0, function* () {
        let logOffset = 0;
        const errors = [];
        const warnings = [];
        const factors = [options.appName, taskName, `${options.importServiceUrl}/status`];
        const mac = digest_1.hmac(factors, options.secret);
        const isHttps = options.importServiceUrl.startsWith('https');
        const requestBaseOptions = {
            transport: isHttps ? getHttpsTransport(options) : undefined,
            headers: {
                'User-Agent': 'Sitecore/JSS-Import',
                'Cache-Control': 'no-cache',
                'X-JSS-Auth': mac,
            },
            proxy: extractProxy(options.proxy),
            maxRedirects: 0,
            httpsAgent: isHttps
                ? new https_1.Agent({
                    // we turn off normal CA cert validation when we are whitelisting a single cert thumbprint
                    rejectUnauthorized: options.acceptCertificate ? false : true,
                    // needed to allow whitelisting a cert thumbprint if a connection is reused
                    maxCachedSessions: options.acceptCertificate ? 0 : undefined,
                })
                : undefined,
        };
        if (options.debugSecurity) {
            console.log(`Deployment status security factors: ${factors}`);
            console.log(`Deployment status HMAC: ${mac}`);
        }
        return new Promise((resolve, reject) => {
            /**
             * Send job status request
             */
            function sendJobStatusRequest() {
                axios_1.default
                    .get(`${options.importServiceUrl}/status?appName=${options.appName}&jobName=${taskName}&after=${logOffset}`, requestBaseOptions)
                    .then((response) => {
                    const body = response.data;
                    try {
                        const { state, messages } = body;
                        messages.forEach((entry) => {
                            logOffset++;
                            const entryBits = /^(\[([A-Z]+)\] )?(.+)/.exec(entry);
                            let entryLevel = 'INFO';
                            let message = entry;
                            if (entryBits && entryBits[2]) {
                                entryLevel = entryBits[2];
                                // 3 = '[] ' in say [INFO] My log message
                                // we're not using the capture group as the message might be multi-line
                                message = entry.substring(entryLevel.length + 3);
                            }
                            if (message.startsWith('[JSS] - ')) {
                                message = message.substring(8);
                            }
                            logJobStatus({ message, entryLevel, warnings, errors });
                        });
                        if (state === 'Finished') {
                            finishWatchJobStatusTask({ warnings, errors, resolve, reject });
                            return;
                        }
                        setTimeout(sendJobStatusRequest, 1000);
                    }
                    catch (error) {
                        console.error(chalk_1.default.red(`Unexpected error processing reply from import status service: ${error}`));
                        console.error(chalk_1.default.red(`Response: ${body}`));
                        console.error(chalk_1.default.red('Consult the Sitecore logs for details.'));
                        reject(error);
                    }
                })
                    .catch((error) => {
                    console.error(chalk_1.default.red('Unexpected response from import status service. The import task is probably still running; check the Sitecore logs for details.'));
                    if (error.response) {
                        console.error(chalk_1.default.red(`Status message: ${error.response.statusText}`));
                        console.error(chalk_1.default.red(`Status: ${error.response.status}`));
                    }
                    else {
                        console.error(chalk_1.default.red(error.message));
                    }
                    reject();
                });
            }
            setTimeout(sendJobStatusRequest, 1000);
        });
    });
}
/**
 * @param {PackageDeployOptions} options
 */
function packageDeploy(options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!options.secret) {
            throw new Error('Deployment secret was not passed. A shared secret must be configured on both the Sitecore app config and the JS app config');
        }
        if (options.secret.length < 32) {
            throw new Error('Deployment secret was too short. Use a RANDOM (not words or phrases) secret at least 32 characters long.');
        }
        let packageFile = null;
        fs_1.default.readdirSync(options.packagePath).forEach((file) => {
            if (file.startsWith(options.appName) && file.endsWith('.manifest.zip')) {
                packageFile = path_1.default.join(options.packagePath, file);
            }
        });
        if (!packageFile) {
            throw new Error('Package file not found, ensure you have generated the package first.');
        }
        const factors = [options.appName, options.importServiceUrl, yield digest_1.digest(packageFile)];
        if (options.debugSecurity) {
            console.log('Security debugging is enabled. Do not use this unless absolutely necessary.');
            console.log(`Deployment secret: ${options.secret}`);
            console.log(`Deployment security factors: ${factors}`);
            console.log(`Deployment HMAC: ${digest_1.hmac(factors, options.secret)}`);
        }
        const formData = new form_data_1.default();
        formData.append('path', fs_1.default.createReadStream(packageFile));
        formData.append('appName', options.appName);
        const isHttps = options.importServiceUrl.startsWith('https');
        const requestBaseOptions = {
            transport: isHttps ? getHttpsTransport(options) : undefined,
            headers: Object.assign({ 'User-Agent': 'Sitecore/JSS-Import', 'Cache-Control': 'no-cache', 'X-JSS-Auth': digest_1.hmac(factors, options.secret) }, formData.getHeaders()),
            proxy: extractProxy(options.proxy),
            httpsAgent: isHttps
                ? new https_1.Agent({
                    // we turn off normal CA cert validation when we are whitelisting a single cert thumbprint
                    rejectUnauthorized: options.acceptCertificate ? false : true,
                    // needed to allow whitelisting a cert thumbprint if a connection is reused
                    maxCachedSessions: options.acceptCertificate ? 0 : undefined,
                })
                : undefined,
            maxRedirects: 0,
        };
        console.log(`Sending package ${packageFile} to ${options.importServiceUrl}...`);
        return new Promise((resolve, reject) => {
            axios_1.default
                .post(options.importServiceUrl, formData, requestBaseOptions)
                .then((response) => {
                const body = response.data;
                console.log(chalk_1.default.green(`Sitecore has accepted import task ${body}`));
                resolve(body);
            })
                .catch((error) => {
                console.error(chalk_1.default.red('Unexpected response from import service:'));
                if (error.response) {
                    console.error(chalk_1.default.red(`Status message: ${error.response.statusText}`));
                    console.error(chalk_1.default.red(`Status: ${error.response.status}`));
                }
                else {
                    console.error(chalk_1.default.red(error.message));
                }
                reject();
            });
        }).then((taskName) => watchJobStatus(options, taskName));
    });
}
exports.packageDeploy = packageDeploy;
/**
 * Creates valid proxy object which fit to axios configuration
 * @param {string} [proxy] proxy url
 */
function extractProxy(proxy) {
    if (!proxy)
        return undefined;
    try {
        const proxyUrl = new URL(proxy);
        return {
            protocol: proxyUrl.protocol.slice(0, -1),
            host: proxyUrl.hostname,
            port: +proxyUrl.port,
        };
    }
    catch (error) {
        console.error(chalk_1.default.red(`Invalid proxy url provided ${proxy}`));
        process.exit(1);
    }
}
exports.extractProxy = extractProxy;
/**
 * Provides way to customize axios request adapter
 * in order to execute certificate pinning before request sent:
 * {@link https://github.com/axios/axios/issues/2808}
 * @param {PackageDeployOptions} options
 */
function getHttpsTransport(options) {
    return Object.assign(Object.assign({}, https_1.default), { request: (reqOptions, callback) => {
            const req = https_1.default.request(Object.assign({}, reqOptions), callback);
            applyCertPinning(req, options);
            return req;
        } });
}
exports.getHttpsTransport = getHttpsTransport;
