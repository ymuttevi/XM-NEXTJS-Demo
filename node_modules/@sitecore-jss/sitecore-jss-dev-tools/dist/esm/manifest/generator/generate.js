var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import { configLoader } from '../../pipelines';
import chalk from 'chalk';
import * as fs from 'fs-extra';
import * as path from 'path';
import { importModules } from '../utils';
import { createManifestInstance } from './manifest';
const processSpecFile = (moduleWrapper, manifest) => __awaiter(void 0, void 0, void 0, function* () {
    const module = yield moduleWrapper();
    if (!module.default || typeof module.default !== 'function') {
        console.warn('no valid default export defined on module', module);
        return manifest;
    }
    const moduleResult = module.default(manifest);
    // spec files should only return undefined or a promise, we only care about the promise
    if (moduleResult && moduleResult.then) {
        // result is a promise
        // resolve the promise and return the manifest instance so that any non-async spec files
        // after the current file will receive the manifest instance as an argument
        return moduleResult.then(() => manifest);
    }
    return manifest;
});
const processSpecFiles = ({ fileGlobs, manifestInstance, }) => __awaiter(void 0, void 0, void 0, function* () {
    const moduleWrappers = importModules({ fileGlobs });
    let manifest = manifestInstance;
    for (const moduleWrapper of moduleWrappers) {
        // eslint-disable-next-line no-await-in-loop
        manifest = yield processSpecFile(moduleWrapper, manifest);
    }
    return manifest;
});
const initRequire = (requireArg) => {
    if (!requireArg) {
        return;
    }
    try {
        if (requireArg.startsWith('.')) {
            requireArg = path.join(process.cwd(), requireArg);
        }
        require(requireArg);
    }
    catch (e) {
        throw new Error(`Unable to load manifest require ${requireArg}: ${e}`);
    }
};
const copyMedia = (mediaPaths, outputPath) => {
    const seen = new Set();
    return mediaPaths
        .filter((item) => (seen.has(item.src) ? false : seen.add(item.src)))
        .map((mediaPath) => {
        if (!mediaPath.src) {
            console.warn(`Media field value ${JSON.stringify(mediaPath)} did not have an expected 'src' property. Its media item will not be deployed.`);
            return { success: false };
        }
        const mediaSourcePath = path.isAbsolute(mediaPath.src) ? `.${mediaPath.src}` : mediaPath.src;
        if (fs.existsSync(mediaSourcePath)) {
            if (!fs.statSync(mediaSourcePath).isFile()) {
                console.warn(`Source media path referred to in manifest data is not a file: ${mediaSourcePath}`);
                return { success: false };
            }
            const mediaDestinationPath = path.join(path.dirname(outputPath), mediaPath.src);
            const mediaDestinationFolder = path.dirname(mediaDestinationPath);
            fs.ensureDirSync(mediaDestinationFolder);
            fs.copySync(mediaSourcePath, mediaDestinationPath);
            console.log(`copied media from: ${mediaSourcePath} to: ${mediaDestinationPath}`);
            return { source: mediaSourcePath, destination: mediaDestinationPath, success: true };
        }
        throw `Source media file referred to in manifest data doesn't exist: ${mediaSourcePath}`;
    });
};
const writeOutput = ({ outputPath, manifest, excludeMedia, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (outputPath !== 'console') {
        yield fs.ensureFile(outputPath);
        // we copy the media first, because we no longer need the media prop after that
        if (!excludeMedia && manifest.media) {
            copyMedia(manifest.media, outputPath);
        }
        // we remove the media prop as it's unused by the manifest after copying media
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { media } = manifest, finalManifest = __rest(manifest, ["media"]);
        yield fs.writeJson(outputPath, finalManifest, { spaces: 2 });
        console.log(chalk.green(`Manifest has been generated and written to ${outputPath}`));
        return finalManifest;
    }
    console.log('manifest', JSON.stringify(manifest, null, 2));
    return manifest;
});
const getPipelineConfig = ({ patchGlobs }) => __awaiter(void 0, void 0, void 0, function* () {
    const manifestConfig = yield configLoader({
        fileGlobs: ['./pipelines/**/pipeline.config.js'],
        workingDirectory: __dirname,
    });
    const patchedConfig = patchGlobs
        ? yield configLoader({
            fileGlobs: patchGlobs,
            existingConfig: manifestConfig,
            allowEmptyGlobs: true,
        })
        : manifestConfig;
    return patchedConfig;
});
/**
 * generates the JSON manifest and returns it as a variable
 * NOTE: media is not copied into the manifest when using this method,
 * and no files are written to disk. Use generateToFile() to make a manifest
 * that is designed to get packaged/imported.
 *
 * @param {GenerateOptions} config
 */
export function generateToVariable({ requireArg, fileGlobs, pipelines, appName, excludeItems = false, excludeDictionary = false, language, pipelinePatchFileGlobs, debug, wipe, rootPlaceholders, skipPlaceholderBlacklist, }) {
    return __awaiter(this, void 0, void 0, function* () {
        initRequire(requireArg);
        const finalPipelines = pipelines || (yield getPipelineConfig({ patchGlobs: pipelinePatchFileGlobs }));
        let manifestInstance = createManifestInstance({
            pipelines: finalPipelines,
            appName,
            excludeItems,
            excludeDictionary,
            language,
            debug,
            wipe,
            rootPlaceholders,
            skipPlaceholderBlacklist,
        });
        manifestInstance = yield processSpecFiles({ fileGlobs, manifestInstance });
        const manifestOutput = yield manifestInstance.getManifest();
        return manifestOutput;
    });
}
/**
 * generates a JSON manifest and writes its contents to a directory. Media referenced in the manifest
 * is also copied to the directory.
 *
 * @param {GenerateToFileOptions} config
 */
export function generateToFile(_a) {
    var { outputPath = 'console', excludeMedia = false } = _a, generateToVariableOptions = __rest(_a, ["outputPath", "excludeMedia"]);
    return __awaiter(this, void 0, void 0, function* () {
        const manifestOutput = yield generateToVariable(generateToVariableOptions);
        return writeOutput({ outputPath, manifest: manifestOutput, excludeMedia });
    });
}
