var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { generateToFile, generateToVariable } from './generator/generate';
import { watch } from 'chokidar';
import { dirname, join } from 'path';
export class ManifestManager {
    constructor({ rootPath = process.cwd(), sourceFiles = [
        './sitecore/definitions/**/*.sitecore.js',
        './sitecore/definitions/**/*.sitecore.ts',
    ], watchOnlySourceFiles = [], requireArg, outputPath = './sitecore/manifest/sitecore-import.json', pipelinePatchFiles = ['./sitecore/pipelines/**/*.patch.js'], appName = 'JssDisconnectedService', }) {
        this.initialManifest = true;
        if (!requireArg && requireArg !== null) {
            requireArg = './sitecore/definitions/config.js';
        }
        this.manifestArgs = {
            fileGlobs: sourceFiles,
            requireArg,
            appName,
            excludeItems: false,
            excludeMedia: false,
            excludeDictionary: false,
            outputPath,
            language: 'en',
            pipelinePatchFileGlobs: pipelinePatchFiles,
            debug: false,
        };
        this.rootPath = rootPath;
        if (typeof sourceFiles === 'string') {
            // eslint-disable-next-line no-param-reassign
            sourceFiles = [sourceFiles];
        }
        if (typeof watchOnlySourceFiles === 'string') {
            // eslint-disable-next-line no-param-reassign
            watchOnlySourceFiles = [watchOnlySourceFiles];
        }
        if (typeof pipelinePatchFiles === 'string') {
            // eslint-disable-next-line no-param-reassign
            pipelinePatchFiles = [pipelinePatchFiles];
        }
        this.watcherSourcePaths = [...sourceFiles, ...watchOnlySourceFiles, ...pipelinePatchFiles];
        this.getManifest = this.getManifest.bind(this);
        this.getManifestPath = this.getManifestPath.bind(this);
        this.setManifestUpdatedCallback = this.setManifestUpdatedCallback.bind(this);
    }
    setManifestUpdatedCallback(callback) {
        if (!callback || typeof callback !== 'function') {
            throw new Error('Provided callback argument was undefined or not a function');
        }
        if (this.watcher && this.watcher.close) {
            this.watcher.close();
        }
        // start a watch on the source files and invoke the callback when the manifest is updated
        this.watcher = watch(this.watcherSourcePaths, {
            ignoreInitial: true,
            ignorePermissionErrors: true,
            cwd: this.rootPath,
        })
            .on('all', (event, path) => __awaiter(this, void 0, void 0, function* () {
            console.log(`Manifest source file ${path} changed (${event}), reloading manifest...`);
            try {
                callback(yield generateToVariable(this.manifestArgs));
            }
            catch (e) {
                console.error(e);
            }
        }))
            .on('error', (error) => console.error(`Manifest watcher error: ${error}`));
        console.log('Manifest manager is watching for manifest source file changes...');
    }
    getManifestPath() {
        return join(this.rootPath, dirname(this.manifestArgs.outputPath));
    }
    getManifest(language) {
        if (language) {
            this.manifestArgs.language = language;
        }
        if (this.initialManifest) {
            // initial manifesting writes to disk, so that we have manifest media
            this.initialManifest = false;
            return generateToFile(this.manifestArgs);
        }
        // subsequent manifestings can be to memory, as the content is only being redone
        return generateToVariable(this.manifestArgs);
    }
}
