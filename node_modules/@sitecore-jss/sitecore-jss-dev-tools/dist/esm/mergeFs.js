import fs from 'fs';
import yaml from 'js-yaml';
import path from 'path';
const IS_HIDDEN_FILE = (file) => path.basename(file).startsWith('.');
const tryParseJsonOrYaml = (jsonString) => {
    try {
        const json = yaml.safeLoad(jsonString);
        // handle non-exception-throwing cases
        if (json && typeof json === 'object' && json !== null) {
            return json;
        }
    }
    catch (e) {
        console.error(e);
    }
    return false;
};
const processFileSync = (filePath, parseFileContents) => {
    // if no encoding is specified, readFileSync returns a buffer instead of a string
    const contents = fs.readFileSync(filePath, 'utf8');
    if (contents) {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        let contentObject;
        if (parseFileContents) {
            contentObject = parseFileContents(filePath, contents);
        }
        if (!contentObject) {
            contentObject = tryParseJsonOrYaml(contents);
        }
        if (contentObject) {
            return {
                filename: path.basename(filePath),
                path: path.resolve(filePath),
                contents: contentObject,
            };
        }
    }
    return null;
};
const readDirSync = (dir) => {
    const result = {
        filesList: [],
        dirList: [],
    };
    if (IS_HIDDEN_FILE(dir)) {
        return result;
    }
    const list = fs.readdirSync(dir);
    if (!list) {
        return result;
    }
    list.forEach((file) => {
        const filePath = path.join(dir, file);
        if (IS_HIDDEN_FILE(file)) {
            return;
        }
        const stats = fs.statSync(filePath);
        if (stats && stats.isDirectory()) {
            result.dirList.push(filePath);
        }
        else {
            result.filesList.push(filePath);
        }
    });
    return result;
};
const walkSync = (dir, parseFileContents, depth = 0) => {
    const results = {
        path: path.resolve(dir),
        name: path.basename(dir),
        files: [],
        folders: [],
    };
    const { filesList, dirList } = readDirSync(dir);
    results.files = filesList
        .map((file) => processFileSync(file, parseFileContents))
        .filter((file) => file)
        .map((file) => file);
    results.folders = dirList.map((dirPath) => walkSync(dirPath, parseFileContents, depth + 1));
    return results;
};
export const mergeFs = (rootPath, parseFileContents) => new Promise((resolve, reject) => {
    if (!rootPath) {
        reject(new Error('rootPath is not defined'));
    }
    const result = walkSync(rootPath, parseFileContents);
    if (result) {
        resolve(result);
    }
    else {
        reject(new Error('no result generated'));
    }
});
