"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleEditorAnchors = exports.resetEditorChromes = exports.isEditorActive = exports.HorizonEditor = exports.ChromeRediscoveryGlobalFunctionName = exports.ExperienceEditor = void 0;
const is_server_1 = __importDefault(require("./is-server"));
/**
 * Static utility class for Sitecore Experience Editor
 */
class ExperienceEditor {
    /**
     * Determines whether the current execution context is within a Experience Editor.
     * Experience Editor environment can be identified only in the browser
     * @returns true if executing within a Experience Editor
     */
    static isActive() {
        if (is_server_1.default()) {
            return false;
        }
        // eslint-disable-next-line
        const sc = window.Sitecore;
        return Boolean(sc && sc.PageModes && sc.PageModes.ChromeManager);
    }
    static resetChromes() {
        if (is_server_1.default()) {
            return;
        }
        window.Sitecore.PageModes.ChromeManager.resetChromes();
    }
}
exports.ExperienceEditor = ExperienceEditor;
/**
 * Copy of chrome rediscovery contract from Horizon (chrome-rediscovery.contract.ts)
 */
exports.ChromeRediscoveryGlobalFunctionName = {
    name: 'Sitecore.Horizon.ResetChromes',
};
/**
 * Static utility class for Sitecore Horizon Editor
 */
class HorizonEditor {
    /**
     * Determines whether the current execution context is within a Horizon Editor.
     * Horizon Editor environment can be identified only in the browser
     * @returns true if executing within a Horizon Editor
     */
    static isActive() {
        if (is_server_1.default()) {
            return false;
        }
        // Horizon will add "sc_horizon=editor" query string parameter for the editor and "sc_horizon=simulator" for the preview
        return window.location.search.indexOf('sc_horizon=editor') > -1;
    }
    static resetChromes() {
        if (is_server_1.default()) {
            return;
        }
        // Reset chromes in Horizon
        window[exports.ChromeRediscoveryGlobalFunctionName.name] &&
            window[exports.ChromeRediscoveryGlobalFunctionName.name]();
    }
}
exports.HorizonEditor = HorizonEditor;
/**
 * Determines whether the current execution context is within a Sitecore editor.
 * Sitecore Editor environment can be identified only in the browser
 * @returns true if executing within a Sitecore editor
 */
const isEditorActive = () => {
    return ExperienceEditor.isActive() || HorizonEditor.isActive();
};
exports.isEditorActive = isEditorActive;
/**
 * Resets Sitecore editor "chromes"
 */
const resetEditorChromes = () => {
    if (ExperienceEditor.isActive()) {
        ExperienceEditor.resetChromes();
    }
    else if (HorizonEditor.isActive()) {
        HorizonEditor.resetChromes();
    }
};
exports.resetEditorChromes = resetEditorChromes;
/**
 * @description in Experience Editor, anchor tags
 * with both onclick and href attributes will use the href, blocking the onclick from firing.
 * This function makes it so the anchor tags function as intended in the sample when using Experience Editor
 *
 * The Mutation Observer API is used to observe changes to the body, then select all elements with href="#" and an onclick,
 * and replaces the # value with javascript:void(0); which prevents the anchor tag from blocking the onclick event handler.
 * @see Mutation Observer API: https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/MutationObserver
 */
const handleEditorAnchors = () => {
    // The sample gives the href attribute priority over the onclick attribute if both are present, so we must replace
    // the href attribute to avoid overriding the onclick in Experience Editor
    if (!window || !ExperienceEditor.isActive()) {
        return;
    }
    const targetNode = document.querySelector('body');
    const callback = (mutationList) => {
        mutationList.forEach((mutation) => {
            const btns = document.querySelectorAll('.scChromeDropDown > a[href="#"], .scChromeDropDown > a[href="#!"], a[onclick]');
            if (mutation.type === 'childList') {
                btns.forEach((link) => {
                    link.href = 'javascript:void(0);';
                });
            }
            return;
        });
    };
    const observer = new MutationObserver(callback);
    const observerOptions = {
        childList: true,
        subtree: true,
    };
    if (targetNode) {
        observer.observe(targetNode, observerOptions);
    }
};
exports.handleEditorAnchors = handleEditorAnchors;
