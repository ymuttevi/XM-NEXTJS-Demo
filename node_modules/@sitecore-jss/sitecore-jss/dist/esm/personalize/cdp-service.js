var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import debug from '../debug';
import { AxiosDataFetcher } from '../axios-fetcher';
import { isTimeoutError } from '../utils';
export const DEFAULT_CHANNEL = 'WEB';
export class CdpService {
    constructor(config) {
        this.config = config;
        /**
         * Provides default @see AxiosDataFetcher data fetcher
         * @param {DataFetcherConfig} config
         * @returns default fetcher
         */
        this.getDefaultFetcher = (config) => {
            const fetcher = new AxiosDataFetcher(Object.assign({ debugger: debug.personalize }, config));
            return (url, data) => fetcher.fetch(url, data);
        };
        this.timeout = config.timeout || 250;
    }
    /**
     * Executes targeted experience for a page and params to determine the variant to render.
     * @param {string} contentId the friendly content id of the page
     * @param {string} browserId the browser id
     * @param {string} userAgent the user agent
     * @param {string} pointOfSale current point of sale
     * @param {ExperienceParams} params the experience params for the user
     * @returns {ExecuteExperienceResult} the execute experience result
     */
    executeExperience(contentId, browserId, userAgent, pointOfSale, params) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = this.getExecuteExperienceUrl();
            debug.personalize('executing experience for %s %s %s %o', contentId, browserId, userAgent, params);
            const headers = { 'User-Agent': userAgent };
            const fetcher = this.getFetcher(headers);
            try {
                const response = yield fetcher(endpoint, {
                    clientKey: this.config.clientKey,
                    pointOfSale: pointOfSale,
                    channel: (_a = this.config.channel) !== null && _a !== void 0 ? _a : DEFAULT_CHANNEL,
                    browserId,
                    friendlyId: contentId,
                    params,
                });
                response.data.variantId === '' && (response.data.variantId = undefined);
                return response.data.variantId || undefined;
            }
            catch (error) {
                if (isTimeoutError(error)) {
                    return;
                }
                throw error;
            }
        });
    }
    /**
     * Generates a new browser id
     * @returns {string} browser id
     */
    generateBrowserId() {
        return __awaiter(this, void 0, void 0, function* () {
            const endpoint = this.getGenerateBrowserIdUrl();
            debug.personalize('generating browser id');
            const fetcher = this.getFetcher();
            try {
                const response = yield fetcher(endpoint);
                return response.data.ref;
            }
            catch (error) {
                if (isTimeoutError(error)) {
                    return;
                }
                throw error;
            }
        });
    }
    /**
     * Get formatted URL for generateBrowserId call
     * @returns {string} formatted URL
     */
    getGenerateBrowserIdUrl() {
        return `${this.config.endpoint}/v1.2/browser/create.json?client_key=${this.config.clientKey}&message={}`;
    }
    /**
     * Get formatted URL for executeExperience call
     * @returns {string} formatted URL
     */
    getExecuteExperienceUrl() {
        return `${this.config.endpoint}/v2/callFlows`;
    }
    /**
     * Returns provided data fetcher otherwise default one
     * @param {Record<string, string>} [headers] Optional headers
     * @returns {HttpDataFetcher} data fetcher
     */
    getFetcher(headers) {
        return this.config.dataFetcherResolver
            ? this.config.dataFetcherResolver({ timeout: this.timeout, headers })
            : this.getDefaultFetcher({ timeout: this.timeout, headers });
    }
}
