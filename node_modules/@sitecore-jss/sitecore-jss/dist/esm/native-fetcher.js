var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
import debuggers from './debug';
import TimeoutPromise from './utils/timeout-promise';
export class NativeDataFetcher {
    constructor(config = {}) {
        this.config = config;
    }
    /**
     * Implements a data fetcher. @see HttpDataFetcher<T> type for implementation details/notes.
     * @param {string} url The URL to request; may include query string
     * @param {unknown} [data] Optional data to POST with the request.
     * @returns {Promise<HttpResponse<T>>} response
     */
    fetch(url, data) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const _b = this.config, { debugger: debugOverride, fetch: fetchOverride } = _b, init = __rest(_b, ["debugger", "fetch"]);
            const fetchImpl = fetchOverride || fetch;
            const debug = debugOverride || debuggers.http;
            const requestInit = this.getRequestInit(init, data);
            const fetchWithOptionalTimeout = [fetchImpl(url, requestInit)];
            if (init.timeout) {
                this.abortTimeout = new TimeoutPromise(init.timeout);
                fetchWithOptionalTimeout.push(this.abortTimeout.start);
            }
            // Note a goal here is to provide consistent debug logging and error handling
            // as we do in AxiosDataFetcher and GraphQLRequestClient
            const { headers: reqHeaders } = requestInit, rest = __rest(requestInit, ["headers"]);
            debug('request: %o', Object.assign({ url, headers: this.extractDebugHeaders(reqHeaders) }, rest));
            const response = yield Promise.race(fetchWithOptionalTimeout)
                .then((res) => {
                var _a;
                (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();
                return res;
            })
                .catch((error) => {
                var _a;
                (_a = this.abortTimeout) === null || _a === void 0 ? void 0 : _a.clear();
                debug('request error: %o', error);
                throw error;
            });
            // Note even an error status may send useful json data in response (which we want for logging)
            let respData = undefined;
            const isJson = (_a = response.headers.get('Content-Type')) === null || _a === void 0 ? void 0 : _a.includes('application/json');
            if (isJson) {
                respData = yield response.json().catch((error) => {
                    debug('response.json() error: %o', error);
                });
            }
            const debugResponse = {
                status: response.status,
                statusText: response.statusText,
                headers: this.extractDebugHeaders(response.headers),
                url: response.url,
                redirected: response.redirected,
                data: respData,
            };
            if (!response.ok) {
                debug('response error: %o', debugResponse);
                throw new Error(`HTTP ${response.status} ${response.statusText}`);
            }
            debug('response: %o', debugResponse);
            return Object.assign(Object.assign({}, response), { data: respData });
        });
    }
    /**
     * Determines settings for the request
     * @param {RequestInit} init Custom settings for request
     * @param {unknown} [data] Optional data to POST with the request
     * @returns {RequestInit} The final request settings
     */
    getRequestInit(init = {}, data) {
        // This is a focused implementation (GET or POST only using JSON input/output)
        // so we are opinionated about method, body, and Content-Type
        init.method = data ? 'POST' : 'GET';
        init.body = data ? JSON.stringify(data) : undefined;
        const headers = new Headers(init.headers);
        headers.set('Content-Type', 'application/json');
        init.headers = headers;
        return init;
    }
    /**
     * Safely extract all headers for debug logging
     * @param {HeadersInit} incomingHeaders Incoming headers
     * @returns Object with headers as key/value pairs
     */
    extractDebugHeaders(incomingHeaders = {}) {
        const headers = {};
        if (typeof (incomingHeaders === null || incomingHeaders === void 0 ? void 0 : incomingHeaders.forEach) !== 'string' && incomingHeaders.forEach) {
            incomingHeaders === null || incomingHeaders === void 0 ? void 0 : incomingHeaders.forEach((value, key) => {
                headers[key] = value;
            });
        }
        return headers;
    }
}
