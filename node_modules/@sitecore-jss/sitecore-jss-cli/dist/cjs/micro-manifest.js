"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const sitecore_jss_dev_tools_1 = require("@sitecore-jss/sitecore-jss-dev-tools");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const tmp_1 = __importDefault(require("tmp"));
const resolve_package_1 = __importDefault(require("./resolve-package"));
const manifest_1 = require("./scripts/manifest");
const package_1 = require("./scripts/package");
/**
 * @param {any} argv
 * @param {string} manifestContents
 */
function microManifest(
// eslint-disable-next-line @typescript-eslint/no-explicit-any
argv, manifestContents) {
    return __awaiter(this, void 0, void 0, function* () {
        sitecore_jss_dev_tools_1.verifySetup();
        const packageJson = yield resolve_package_1.default();
        if (!argv.appName) {
            argv.appName = packageJson.config.appName;
        }
        if (!argv.appName) {
            throw new Error('App Name was not defined as a parameter or in the package.json config');
        }
        const jssConfig = yield sitecore_jss_dev_tools_1.resolveScJssConfig({ configPath: argv.config });
        if (!argv.deployUrl) {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            const legacyConfig = jssConfig.sitecore;
            argv.deployUrl = legacyConfig.shipUrl ? legacyConfig.shipUrl : jssConfig.sitecore.deployUrl;
        }
        if (!argv.deployUrl) {
            throw new Error('deployUrl was not defined as a parameter or in the scjssconfig.json file');
        }
        if (/\/ship\/services\/package/.test(argv.deployUrl)) {
            throw new Error('deployUrl appears to be a Sitecore.Ship endpoint. JSS no longer uses Ship. You will need to reconfigure your endpoint to the JSS deploy service and provide an app shared secret to deploy.');
        }
        if (!argv.deploySecret) {
            argv.deploySecret = jssConfig.sitecore.deploySecret;
        }
        if (!argv.deploySecret) {
            throw new Error('deploySecret was not defined as a parameter or in the scjssconfig.json file');
        }
        return new Promise((resolve, reject) => {
            tmp_1.default.dir({ unsafeCleanup: true }, (err, tempDir, cleanupTempDir) => __awaiter(this, void 0, void 0, function* () {
                if (err) {
                    reject(err);
                }
                // generate micro-manifest to deploy with
                const manifestFolder = path_1.default.join(tempDir, 'manifest');
                if (!fs_1.default.existsSync(manifestFolder)) {
                    fs_1.default.mkdirSync(manifestFolder);
                }
                const manifestArgs = Object.assign({ manifestSourceFiles: [path_1.default.join(manifestFolder, 'tempManifestSource.js')], manifestOutputPath: path_1.default.join(manifestFolder, 'tempManifest.json'), noDictionary: true }, argv);
                // write temporary manifest source file to generate from
                fs_1.default.writeFileSync(manifestArgs.manifestSourceFiles[0], manifestContents, 'utf8');
                yield manifest_1.handler(manifestArgs);
                // run a package deploy of our custom manifest
                const packageDir = path_1.default.join(tempDir, 'package');
                if (!fs_1.default.existsSync(packageDir)) {
                    fs_1.default.mkdirSync(packageDir);
                }
                const packageArgs = Object.assign({ skipManifest: true, noFiles: true, packageOutputPath: path_1.default.join(packageDir, 'tempPackage.manifest.zip') }, manifestArgs);
                yield package_1.handler(packageArgs);
                const deployArgs = {
                    appName: argv.appName,
                    packagePath: packageArgs.packageOutputPath,
                    importServiceUrl: argv.deployUrl,
                    secret: argv.deploySecret,
                    debugSecurity: argv.debugSecurity,
                    acceptCertificate: argv.acceptCertificate,
                };
                yield sitecore_jss_dev_tools_1.packageDeploy(deployArgs);
                cleanupTempDir();
                resolve();
            }));
        });
    });
}
exports.default = microManifest;
